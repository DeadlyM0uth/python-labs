# Лабораторная работа 10 — Оптимизация вычислений: потоки, процессы, Cython и noGIL 
**Цель:** исследовать способы оптимизации вычислений на примере численного интегрирования методом прямоугольников (функция `integrate`) и сравнить: чистый Python, многопоточность, многопроцессность, Cython-оптимизацию и Cython с noGIL.

## 1) Реализации и структура репозитория 

- `iteration1/iteration1.py` — базная реализация `integrate` (Python, аннотации типов, doctests)
- `iteration1/tests.py` — unit-тесты для базовой реализации
- `iteration2/iteration2.py` — многопоточная версия (`integrate_threaded`)
- `iteration3/iteration3.py` — многопроцессная версия (`integrate_processed`)
- `iteration4/` — Cython-оптимизация (файлы: `integrate_cython.pyx`, `iteration4.py`, `setup.py`, html-аннотация `integrate_cython.html`)
- `iteration5/` — Cython noGIL (файлы: `integrate_nogil.pyx`, `iteration5.py`, `setup.py`, `integrate_nogil.html`)
- Скрипты для замеров: `benchmark_iteration1.py`, `benchmark_iteration2.py`, `benchmark_iteration3.py`, `benchmark_iteration4.py`, `benchmark_iteration5.py`

---

## 2) Документация, аннотации и тесты

- Функция `integrate` имеет подробный PEP-257 docstring, типы аргументов и возвращаемое значение (PEP-484), а также два doctest-примера (тригонометрическая и полиномиальная функции).
- Юнит-тесты (`iteration1/tests.py`) покрывают:
  - корректность интеграла sin(x) от 0 до π
  - корректность интеграла x^2 от 0 до 1
  - устойчивость при изменении `n_iter`
  - проверку на обратные пределы интегрирования

---

## 3) Как воспроизвести


```bash
python -m venv .venv
.venv\Scripts\activate
# Для Cython-частей (если вы хотите пересобрать): pip install cython
```

- Запуск doctest (в `iteration1`):

```bash
python iteration1/iteration1.py
```

- Запуск бенчмарков:

```bash
python benchmark_iteration1.py   # базовый замер зависимости времени от n_iter
python benchmark_iteration2.py   # многопоточность (1M итераций)
python benchmark_iteration3.py   # многопроцессы (1M итераций)
python benchmark_iteration4.py   # сравнение Python vs Cython (10M)
python benchmark_iteration5.py   # noGIL (threads) и Cython processes (10M)
```

- Если нужно пересобрать Cython-расширения:

```bash
cd iteration4
python setup.py build_ext --inplace
cd ../iteration5
python setup.py build_ext --inplace
```

---

## 4) Замеры времени — результаты 

**Замер 1 (базовая зависимость от количества итераций)**

| n_iter  | Время на 1 запуск (среднее) |
|--------:|----------------------------:|
| 100     | 0.000015 s                  |
| 1 000   | 0.000139 s                  |
| 10 000  | 0.001686 s                  |
| 100 000 | 0.023999 s                  |
| 1 000 000 | 0.146705 s                |


**Замер 3 (многопроцессный, n_iter=1_000_000)**

| n_jobs | Время (s) |
|------:|----------:|
| 1     | 0.342902  |
| 2     | 0.261692  |
| 4     | 0.210305  |
| 6     | 0.261201  |
| 8     | 0.318642  |

**Замер 4 (Cython vs Python, n_iter=10_000_000)**

| Контекст | Python (s) | Cython (s) | Speedup |
|---------:|-----------:|----------:|--------:|
| Линейная | 1.5114     | 0.9589    | 1.58x   |
| Threaded (4) | 1.3414 | 0.9542    | 1.41x   |
| Processed (4) | 0.7603 | 0.5285   | 1.44x   |

**Замер 5 (noGIL threads vs Cython processes, n_iter=10_000_000)**

- noGIL (threads):

| n_jobs | Время (s) |
|------:|----------:|
| 1     | 0.066464 |
| 2     | 0.058007 |
| 4     | 0.027992 |
| 6     | 0.024740 |
| 8     | 0.031086 |

- Cython (processes):

| n_jobs | Время (s) |
|------:|----------:|
| 1     | 1.167738 |
| 2     | 0.634383 |
| 4     | 0.456787 |
| 6     | 0.447923 |
| 8     | 0.461268 |

---

## 5) Наблюдения и выводы

- **Cython заметно ускоряет линейную реализацию**: в текущих замерах линейная версия ускорилась примерно **1.58x** (Python 1.5114 s → Cython 0.9589 s).
- **Многопоточная Cython** по-прежнему даёт ускорение порядка **~1.4x** по сравнению с Python для 4 потоков (Python 1.3414 s → Cython 0.9542 s).
- **Многопроцессная Cython** показывает хорошее ускорение для 4 работников (Python 0.7603 s → Cython 0.5285 s, ~1.44x) и обычно даёт более устойчивый выигрыш по сравнению с Python-потоками для данного workload.
- **noGIL (Cython threads)** оказался крайне эффективным в этих замерах: очень низкие времена (например, 4 потока → **0.028 s**), что указывает на минимальные накладные расходы и хорошую работу на C-уровне для этого численного ядра. В нашем случае `noGIL threads` превосходят `Cython processes` по скорости при одинаковом количестве рабочих единиц.
- **Чистый Python** (без Cython) выигрывает от процесса (multiprocessing) при масштабировании, но по абсолютным значениям остаётся медленнее по сравнению с Cython-реализациями.

**Ограничения:**
- Результаты аппаратно-зависимы. На другой машине абсолютные времена и поведение масштабирования могут меняться.
- Рекомендуется измерять несколько прогонов и смотреть на медиану/квантили вместо единственного прогона для более стабильной оценки.

---

Автор: Смирнов Вадим, гр 4150.

